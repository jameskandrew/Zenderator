<?php
namespace {{ namespace }}\Models\Base;

use Gone\SDK\Common\Abstracts\AbstractModel;
use {{ namespace }}\Models;

/**
 * Class Base{{ class_name }}Model
 *
 * @package {{ namespace }}\Models\Base
 */
abstract class Base{{ class_name }}Model extends AbstractModel
{
{% if object_name_singular is not empty %}
    const NAME_SINGULAR = "{{ object_name_singular }}";
{% endif %}
{% if object_name_plural is not empty %}
    const NAME_PLURAL = "{{ object_name_plural }}";
{% endif %}
    const TABLE_NAME = "{{ table }}";

{% for propertyName, data in propertyData %}
    const FIELD_{{ propertyName|upper }} = '{{ propertyName }}';
{% endfor %}

    //Property DB Types
{% for propertyName, data in propertyData %}
    const DBTYPE_{{ propertyName|upper }} = '{{ data.type }}';
{% endfor %}

{% for propertyName, data in propertyData %}
{% if data.options is not empty %}
{% for permittedValue in data.options %}
    const {{ propertyName|upper }}_{{ permittedValue|upper|replace({'-':'_'}) }} = '{{ permittedValue }}';
{% endfor %}
{% endif %}
{% endfor %}


    // Constant arrays defined by ENUMs
{% for propertyName, data in propertyData %}
{% if data.options is not empty %}
    const OPTIONS_{{ propertyName|upper }} = [
{% for permittedValue in data.options %}
        self::{{ propertyName|upper }}_{{ permittedValue|upper|replace({'-':'_'}) }},
{% endfor %}
    ];
{% endif %}
{% endfor %}


    // Properties
{% for propertyName, data in propertyData %}
    /** @var {{ data.phpType }} ${{ propertyName }} */
    protected ${{ propertyName }};
{% endfor %}

    public function __toArray() : array
    {
        return [
{% for propertyName, data in propertyData %}
            self::FIELD_{{ propertyName|upper }} => $this->get{{ propertyName }}(),
{% endfor %}
        ];
    }

    // Getters and Setters
{% for propertyName, data in propertyData %}
    /**
    * @return {{ data.phpType }}|null
    */
    public function get{{ data.name }}()
    {
        return $this->{{ propertyName }};
    }

    public function set{{ data.name }}(${{ propertyName }}) : Models\{{ class_name }}Model
    {
        if ($this->{{ propertyName }} !== ${{ propertyName }}) {
            $this->addDirtyKey(self::FIELD_{{ propertyName|upper }});
            $this->{{ propertyName }} = ${{ propertyName }};
        }
        return $this;
    }

{% endfor %}
    public function getPrimaryKeyFields(): array
    {
        return [
{% for key in primary_keys %}
            self::FIELD_{{ key|upper }},
{% endfor %}
        ];
    }

    public static function getPropertyMeta()
    {
        return [
{% for propertyName, data in propertyData %}
            self::FIELD_{{ propertyName|upper }} => [
                'type' => self::DBTYPE_{{ propertyName|upper }},
                'nullable' => {{ data.nullable|json_encode|raw }},
{% if data.length %}
                'length' => {{ data.length }},
{% endif %}
                'unique' => {{ data.unique|json_encode()|raw }},
{% if data.options is not empty %}
                'options' => self::OPTIONS_{{ propertyName|upper }},
{% endif %}
{% if data.related is not empty %}
                'related' => [
{% for related in data.related %}
                    [
                        'model' => Models\{{ related.model }}Model::class,
                        'column' => Models\{{ related.model }}Model::FIELD_{{ related.column|upper }},
                    ],
{% endfor %}
                ],
{% endif %}
{% if data.remote is not empty %}
                'remote' => [
{% for remote in data.remote %}
                    [
                        'model' => Models\{{ remote.model }}Model::class,
                        'column' => Models\{{ remote.model }}Model::FIELD_{{ remote.column|upper }},
                    ],
{% endfor %}
                ],
{% endif %}
            ],
{% endfor %}
        ];
    }
}
